name: openspec-log-guard

on:
  pull_request:
    types: [opened, synchronize, edited, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: read

jobs:
  guard:
    name: openspec-log-guard
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR metadata
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed("No pull_request in event payload");
              return;
            }

            const body = pr.body || "";
            const m = body.match(/Closes\s+#(\d+)/i);
            if (!m) {
              core.setFailed("PR body must contain: 'Closes #<issue-number>'");
              return;
            }

            const issueNumber = m[1];
            const headRef = pr.head.ref || "";
            if (!headRef.startsWith(`task/${issueNumber}-`)) {
              core.setFailed(`Branch must be 'task/${issueNumber}-<slug>', got: ${headRef}`);
              return;
            }

            const { owner, repo } = context.repo;
            const pull_number = pr.number;
            const expectedRunLog = `openspec/_ops/task_runs/ISSUE-${issueNumber}.md`;

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number,
              per_page: 100,
            });

                        if (!files.some((f) => f.filename === expectedRunLog)) {
                          core.setFailed(`PR must include run log file: ${expectedRunLog}`);
                          return;
                        }

                        // Guard: if a PR completes sprint task items (- [ ] -> - [x]), it MUST also update writenow-spec.
                        const writenowSpecPath = "openspec/specs/writenow-spec/spec.md";
                        const sprintTaskRe =
                          /^openspec\/specs\/sprint-[^/]+\/(task_cards|tasks)\/.*\.md$/;
                        const sprintTaskFiles = files.filter((f) => sprintTaskRe.test(f.filename));

                        const parseChecklist = (md) => {
                          const map = new Map();
                          const re = /^\s*-\s*\[( |x|X)\]\s+(.*)\s*$/gm;
                          let m2;
                          while ((m2 = re.exec(md)) !== null) {
                            const checked = (m2[1] || "").toLowerCase() === "x";
                            const text = (m2[2] || "").trim();
                            if (text) map.set(text, checked);
                          }
                          return map;
                        };

                        const getContentOrNull = async (path, ref) => {
                          try {
                            const res = await github.rest.repos.getContent({
                              owner,
                              repo,
                              path,
                              ref,
                            });
                            if (Array.isArray(res.data) || !("content" in res.data)) return null;
                            return Buffer.from(
                              res.data.content,
                              res.data.encoding || "base64"
                            ).toString("utf8");
                          } catch (e) {
                            return null;
                          }
                        };

                        const hasCompletionToggle = async (file) => {
                          const patch = file.patch || "";
                          const patchShowsToggle =
                            /^-\s*-\s*\[\s\]/m.test(patch) && /^\+\s*-\s*\[[xX]\]/m.test(patch);
                          if (patchShowsToggle) return true;

                          // Fallback for truncated/missing patches: compare base/head content.
                          if (!patch) {
                            const base = await getContentOrNull(file.filename, pr.base.sha);
                            const head = await getContentOrNull(file.filename, pr.head.sha);
                            if (!base || !head) return false;

                            const baseItems = parseChecklist(base);
                            const headItems = parseChecklist(head);
                            for (const [text, checked] of baseItems.entries()) {
                              if (checked) continue;
                              if (headItems.get(text) === true) return true;
                            }
                          }

                          return false;
                        };

                        const completedSprintTaskFiles = [];
                        for (const f of sprintTaskFiles) {
                          if (await hasCompletionToggle(f)) completedSprintTaskFiles.push(f.filename);
                        }

                        if (
                          completedSprintTaskFiles.length > 0 &&
                          !files.some((f) => f.filename === writenowSpecPath)
                        ) {
                          core.setFailed(
                            `PR completes sprint task items ([ ] -> [x]) but does not update ${writenowSpecPath}. Files: ${completedSprintTaskFiles.join(
                              ", "
                            )}`
                          );
                          return;
                        }

                        const expectedPrUrl = `https://github.com/${owner}/${repo}/pull/${pull_number}`;
                        const escapeRegExp = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

            const runLogRes = await github.rest.repos.getContent({
              owner,
              repo,
              path: expectedRunLog,
              ref: pr.head.sha,
            });

            if (Array.isArray(runLogRes.data) || !("content" in runLogRes.data)) {
              core.setFailed(`Run log must be a file (not a directory): ${expectedRunLog}`);
              return;
            }

            const runLogContent = Buffer.from(
              runLogRes.data.content,
              runLogRes.data.encoding || "base64"
            ).toString("utf8");

            const requiredRunLogPatterns = [
              {
                name: `header '# ISSUE-${issueNumber}'`,
                re: new RegExp(`^#\\s+ISSUE-${issueNumber}\\s*$`, "m"),
              },
              {
                name: `issue line '- Issue: #${issueNumber}'`,
                re: new RegExp(`^\\-\\s+Issue:\\s+#${issueNumber}\\s*$`, "m"),
              },
              {
                name: `branch line '- Branch: ${headRef}'`,
                re: new RegExp(`^\\-\\s+Branch:\\s+${escapeRegExp(headRef)}\\s*$`, "m"),
              },
              { name: "section '## Plan'", re: /##\s+Plan\b/ },
              { name: "section '## Runs'", re: /##\s+Runs\b/ },
              { name: "at least one '- Command: `...`'", re: /- Command:\s+`[^`]+`/ },
              { name: "at least one '- Key output:'", re: /- Key output:\s+.+/ },
              { name: "at least one '- Evidence:'", re: /- Evidence:\s+.+/ },
            ];

            const missingRunLog = requiredRunLogPatterns
              .filter((p) => !p.re.test(runLogContent))
              .map((p) => p.name);

            if (missingRunLog.length > 0) {
              core.setFailed(
                `Run log ${expectedRunLog} is incomplete. Missing: ${missingRunLog.join(", ")}`
              );
              return;
            }

            const prLineMatch = runLogContent.match(/^- PR:\s*(.+)\s*$/m);
            if (!prLineMatch) {
              core.setFailed(`Run log ${expectedRunLog} must include '- PR: <url>'`);
              return;
            }

            const prValue = prLineMatch[1].trim();
            if (prValue === "" || prValue.includes("<fill")) {
              core.setFailed(
                `Run log ${expectedRunLog} must have PR link filled (expected: ${expectedPrUrl})`
              );
              return;
            }

            if (prValue !== expectedPrUrl) {
              core.setFailed(
                `Run log ${expectedRunLog} PR link must match this PR (expected: ${expectedPrUrl}, got: ${prValue})`
              );
              return;
            }

            const planBodyMatch = runLogContent.match(
              /##\s+Plan\s*\n([\s\S]*?)\n##\s+Runs\b/
            );

            if (!planBodyMatch || !/^- /.test(planBodyMatch[1].trim())) {
              core.setFailed(`Run log ${expectedRunLog} must include a non-empty '## Plan' list`);
              return;
            }

            const commits = await github.paginate(github.rest.pulls.listCommits, {
              owner,
              repo,
              pull_number,
              per_page: 100,
            });

            const missing = commits
              .map((c) => ({ sha: c.sha, message: c.commit?.message || "" }))
              .filter((c) => !c.message.includes(`(#${issueNumber})`));

            if (missing.length > 0) {
              core.setFailed(
                `All commit messages must include '(#${issueNumber})'. Missing: ${missing
                  .map((c) => c.sha.slice(0, 7))
                  .join(", ")}`
              );
              return;
            }
