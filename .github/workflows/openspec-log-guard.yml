name: openspec-log-guard

on:
  pull_request:
    types: [opened, synchronize, edited, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: read

jobs:
  guard:
    name: openspec-log-guard
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR metadata
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed("No pull_request in event payload");
              return;
            }

            const body = pr.body || "";
            const m = body.match(/Closes\s+#(\d+)/i);
            if (!m) {
              core.setFailed("PR body must contain: 'Closes #<issue-number>'");
              return;
            }

            const issueNumber = m[1];
            const headRef = pr.head.ref || "";
            if (!headRef.startsWith(`task/${issueNumber}-`)) {
              core.setFailed(`Branch must be 'task/${issueNumber}-<slug>', got: ${headRef}`);
              return;
            }

            const { owner, repo } = context.repo;
            const pull_number = pr.number;
            const expectedRunLog = `openspec/_ops/task_runs/ISSUE-${issueNumber}.md`;

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number,
              per_page: 100,
            });

            if (!files.some((f) => f.filename === expectedRunLog)) {
              core.setFailed(`PR must include run log file: ${expectedRunLog}`);
              return;
            }

            const expectedPrUrl = `https://github.com/${owner}/${repo}/pull/${pull_number}`;
            const escapeRegExp = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");

            const runLogRes = await github.rest.repos.getContent({
              owner,
              repo,
              path: expectedRunLog,
              ref: pr.head.sha,
            });

            if (Array.isArray(runLogRes.data) || !("content" in runLogRes.data)) {
              core.setFailed(`Run log must be a file (not a directory): ${expectedRunLog}`);
              return;
            }

            const runLogContent = Buffer.from(
              runLogRes.data.content,
              runLogRes.data.encoding || "base64"
            ).toString("utf8");

            const requiredRunLogPatterns = [
              {
                name: `header '# ISSUE-${issueNumber}'`,
                re: new RegExp(`^#\\s+ISSUE-${issueNumber}\\s*$`, "m"),
              },
              {
                name: `issue line '- Issue: #${issueNumber}'`,
                re: new RegExp(`^\\-\\s+Issue:\\s+#${issueNumber}\\s*$`, "m"),
              },
              {
                name: `branch line '- Branch: ${headRef}'`,
                re: new RegExp(`^\\-\\s+Branch:\\s+${escapeRegExp(headRef)}\\s*$`, "m"),
              },
              { name: "section '## Plan'", re: /##\s+Plan\b/ },
              { name: "section '## Runs'", re: /##\s+Runs\b/ },
              { name: "at least one '- Command: `...`'", re: /- Command:\s+`[^`]+`/ },
              { name: "at least one '- Key output:'", re: /- Key output:\s+.+/ },
              { name: "at least one '- Evidence:'", re: /- Evidence:\s+.+/ },
            ];

            const missingRunLog = requiredRunLogPatterns
              .filter((p) => !p.re.test(runLogContent))
              .map((p) => p.name);

            if (missingRunLog.length > 0) {
              core.setFailed(
                `Run log ${expectedRunLog} is incomplete. Missing: ${missingRunLog.join(", ")}`
              );
              return;
            }

            const prLineMatch = runLogContent.match(/^- PR:\s*(.+)\s*$/m);
            if (!prLineMatch) {
              core.setFailed(`Run log ${expectedRunLog} must include '- PR: <url>'`);
              return;
            }

            const prValue = prLineMatch[1].trim();
            if (prValue === "" || prValue.includes("<fill")) {
              core.setFailed(
                `Run log ${expectedRunLog} must have PR link filled (expected: ${expectedPrUrl})`
              );
              return;
            }

            if (prValue !== expectedPrUrl) {
              core.setFailed(
                `Run log ${expectedRunLog} PR link must match this PR (expected: ${expectedPrUrl}, got: ${prValue})`
              );
              return;
            }

            const planBodyMatch = runLogContent.match(
              /##\s+Plan\s*\n([\s\S]*?)\n##\s+Runs\b/
            );

            if (!planBodyMatch || !/^- /.test(planBodyMatch[1].trim())) {
              core.setFailed(`Run log ${expectedRunLog} must include a non-empty '## Plan' list`);
              return;
            }

            const commits = await github.paginate(github.rest.pulls.listCommits, {
              owner,
              repo,
              pull_number,
              per_page: 100,
            });

            const missing = commits
              .map((c) => ({ sha: c.sha, message: c.commit?.message || "" }))
              .filter((c) => !c.message.includes(`(#${issueNumber})`));

            if (missing.length > 0) {
              core.setFailed(
                `All commit messages must include '(#${issueNumber})'. Missing: ${missing
                  .map((c) => c.sha.slice(0, 7))
                  .join(", ")}`
              );
              return;
            }
